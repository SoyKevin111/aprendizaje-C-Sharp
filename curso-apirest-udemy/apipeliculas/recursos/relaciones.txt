ğŸ§  EF Core â€“ RESUMEN PRÃCTICO (Java â†’ .NET)
ğŸ”¹ Reglas base (lÃ©elas siempre)

EF Core â‰ˆ Hibernate

DbContext â‰ˆ EntityManager

Fluent API > Data Annotations

No hay Lazy Loading por defecto

Usa siempre Include()

Controla DeleteBehavior

1ï¸âƒ£ Entidad bÃ¡sica
public class User
{
    public int Id { get; set; }      // PK automÃ¡tica
    public string Name { get; set; } = null!;
}

2ï¸âƒ£ One-to-One (1:1)

ğŸ“Œ FK en la entidad dependiente

public class User
{
    public int Id { get; set; }
    public Profile Profile { get; set; } = null!;
}

public class Profile
{
    public int Id { get; set; }
    public int UserId { get; set; }
    public User User { get; set; } = null!;
}

builder.HasOne(u => u.Profile)
       .WithOne(p => p.User)
       .HasForeignKey<Profile>(p => p.UserId);

3ï¸âƒ£ One-to-Many (1:N) ğŸ”¥
public class Category
{
    public int Id { get; set; }
    public ICollection<Product> Products { get; set; } = [];
}

public class Product
{
    public int Id { get; set; }
    public int CategoryId { get; set; }
    public Category Category { get; set; } = null!;
}

builder.HasMany(c => c.Products)
       .WithOne(p => p.Category)
       .HasForeignKey(p => p.CategoryId);

4ï¸âƒ£ Many-to-Many (N:N) SIMPLE

ğŸ“Œ EF crea la tabla intermedia

builder.HasMany(s => s.Courses)
       .WithMany(c => c.Students)
       .UsingEntity(j => j.ToTable("StudentCourses"));

5ï¸âƒ£ Many-to-Many REAL (con tabla intermedia) âœ…

ğŸ“Œ Recomendado en sistemas reales

public class StudentCourse
{
    public int StudentId { get; set; }
    public int CourseId { get; set; }
    public DateTime CreatedAt { get; set; }
}

builder.HasKey(sc => new { sc.StudentId, sc.CourseId });

6ï¸âƒ£ Cargar relaciones (IMPORTANTÃSIMO)
context.Categories
       .Include(c => c.Products)
       .ToList();


ğŸ“Œ Sin Include() â†’ NO se cargan relaciones

7ï¸âƒ£ DeleteBehavior (no olvides)
.OnDelete(DeleteBehavior.Restrict); // recomendado
// Cascade | SetNull | NoAction

8ï¸âƒ£ ConfiguraciÃ³n limpia (BEST PRACTICE)
public class ProductConfig : IEntityTypeConfiguration<Product>
{
    public void Configure(EntityTypeBuilder<Product> builder)
    {
        builder.Property(p => p.Name)
               .IsRequired()
               .HasMaxLength(100);
    }
}

modelBuilder.ApplyConfigurationsFromAssembly(typeof(AppDbContext).Assembly);

9ï¸âƒ£ Java â†’ .NET traducciÃ³n mental
Java (JPA)	EF Core
@Entity	POCO
@OneToMany	HasMany
mappedBy	WithOne
@JoinTable	UsingEntity
LAZY	Include()
EntityManager	DbContext
ğŸ”¥ Frase para recordar

En EF Core: nada se carga solo, todo se configura explÃ­cito.


#Manejar la organizacion de archivos:

src/
 â”œâ”€â”€ Domain/
 â”‚    â””â”€â”€ Entities/
 â”‚         â”œâ”€â”€ User.cs
 â”‚         â””â”€â”€ Order.cs
 â”‚
 â”œâ”€â”€ Infrastructure/
 â”‚    â””â”€â”€ Persistence/
 â”‚         â”œâ”€â”€ Context/
 â”‚         â”‚    â””â”€â”€ AppDbContext.cs
 â”‚         â”‚
 â”‚         â”œâ”€â”€ Configurations/
 â”‚         â”‚    â”œâ”€â”€ UserConfiguration.cs
 â”‚         â”‚    â”œâ”€â”€ OrderConfiguration.cs
 â”‚         â”‚    â””â”€â”€ OrderItemConfiguration.cs
 â”‚         â”‚
 â”‚         â””â”€â”€ Migrations/
 â”‚
 â””â”€â”€ API/

1ï¸âƒ£ Entidad limpia (sin EF)
public class User
{
    public Guid Id { get; private set; }
    public string Email { get; private set; }
}

âœ”ï¸ Sin:
[Key]
[Column]
[Index]

2ï¸âƒ£ ConfiguraciÃ³n por entidad (IEntityTypeConfiguration)
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

public class UserConfiguration : IEntityTypeConfiguration<User>
{
    public void Configure(EntityTypeBuilder<User> builder)
    {
        builder.ToTable("Users");

        builder.HasKey(u => u.Id);

        builder.Property(u => u.Email)
               .IsRequired()
               .HasMaxLength(150);

        builder.HasIndex(u => u.Email)
               .IsUnique();
    }
}


ğŸ’¡ Ventajas:

Una clase = una entidad
Legible
Testeable
FÃ¡cil de cambiar

3ï¸âƒ£ DbContext minimalista
public class AppDbContext : DbContext
{
    public DbSet<User> Users => Set<User>();
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(
            typeof(AppDbContext).Assembly
        );
    }
}

ğŸ”‘ Esto es clave senior:
El DbContext no sabe quÃ© se configura
Solo aplica configuraciones